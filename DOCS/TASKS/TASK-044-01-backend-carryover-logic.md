# TASK-044-01: Реализация логики переходящих тикетов на бэкенде

**Дата создания:** 2025-12-16 11:01 (UTC+3, Брест)  
**Статус:** Завершена  
**Приоритет:** Высокий  
**Исполнитель:** Bitrix24 Программист (Vue.js Developer)  
**Связь с задачей:** Этап 1 из TASK-044

## Цель этапа

Реализовать логику фильтрации и подсчёта переходящих тикетов на бэкенде в API endpoint `graph-1c-admission-closure.php`. Переходящие тикеты — это тикеты, созданные до начала текущей недели, находящиеся в рабочих стадиях и ещё не закрытые.

## Контекст

- **Текущее состояние:** API возвращает только `newTickets` (созданные в неделю) и `closedTickets` (закрытые в неделю)
- **Проблема:** Не учитываются тикеты, которые были новыми в прошлом периоде, но ещё не закрыты и переходят в текущий период
- **Требуется:** Добавить логику фильтрации переходящих тикетов и подсчёт их количества

## Задачи этапа

### 1) Анализ текущей реализации API
- Изучить файл `api/graph-1c-admission-closure.php`
- Понять, как формируются `newCount` и `closedCount`
- Определить, где сохраняются данные тикетов для агрегации
- Понять структуру запросов к Bitrix24

### 2) Определение логики переходящих тикетов
- Переходящие тикеты должны соответствовать условиям:
  - `createdTime < weekStartUtc` (создан до начала недели)
  - `stageId` ∈ рабочих стадий (DT140_12:UC_0VHWE2, DT140_12:PREPARATION, DT140_12:CLIENT)
  - `stageId` ∉ закрывающих стадий (DT140_12:SUCCESS, DT140_12:FAIL, DT140_12:UC_0GBU8Z)
- Фильтр по продукту `product=1C` применяется первым шагом

### 3) Модификация логики агрегации
- Добавить третий запрос к Bitrix24 для получения переходящих тикетов
- Или использовать существующие запросы и фильтровать на стороне PHP
- Сохранять данные переходящих тикетов для дальнейшей обработки
- Подсчитывать количество переходящих тикетов

### 4) Оптимизация запросов
- Использовать эффективные фильтры в запросах к Bitrix24
- Избегать дублирования данных
- Минимизировать количество запросов к API

## Технические требования

### Определение переходящих тикетов

**Условия:**
1. **Создан до начала недели:**
   - `createdTime < weekStartUtc`
   - Тикет был создан в прошлом периоде

2. **Находится в рабочих стадиях:**
   - `stageId` ∈ {`DT140_12:UC_0VHWE2`, `DT140_12:PREPARATION`, `DT140_12:CLIENT`}
   - Тикет ещё в работе, не закрыт

3. **Не в закрывающих стадиях:**
   - `stageId` ∉ {`DT140_12:SUCCESS`, `DT140_12:FAIL`, `DT140_12:UC_0GBU8Z`}
   - Исключаем уже закрытые тикеты

4. **Фильтр по продукту:**
   - `UF_CRM_7_TYPE_PRODUCT = '1C'` (применяется первым шагом)

### Рабочие стадии (targetStages)

```php
$targetStages = [
    'DT140_12:UC_0VHWE2',   // Сформировано обращение (formed)
    'DT140_12:PREPARATION', // Рассмотрение ТЗ (review)
    'DT140_12:CLIENT'       // Исполнение (execution)
];
```

### Закрывающие стадии (closingStages)

```php
$closingStages = [
    'DT140_12:SUCCESS',     // Успешное закрытие
    'DT140_12:FAIL',        // Отклонено
    'DT140_12:UC_0GBU8Z'    // Закрыли без задачи
];
```

## Ступенчатые подзадачи

1. **Анализ текущего кода**
   - Изучить `api/graph-1c-admission-closure.php`
   - Найти место, где формируются `newCount` и `closedCount`
   - Понять структуру запросов к Bitrix24
   - Определить, где применяется фильтр по продукту

2. **Добавление логики фильтрации переходящих тикетов**
   - Создать функцию `isCarryoverTicket($ticket, $weekStart, $targetStages, $closingStages)`
   - Реализовать проверку всех условий для переходящих тикетов
   - Убедиться, что фильтр по продукту применяется первым

3. **Модификация цикла обработки тикетов**
   - Добавить подсчёт переходящих тикетов в цикле обработки
   - Сохранять данные переходящих тикетов (для будущего использования)
   - Инициализировать переменную `$carryoverCount = 0`

4. **Оптимизация запросов**
   - Определить, нужен ли отдельный запрос для переходящих тикетов
   - Или использовать существующие запросы и фильтровать на PHP
   - Минимизировать количество запросов к Bitrix24

5. **Тестирование логики**
   - Проверить фильтрацию переходящих тикетов
   - Убедиться, что тикеты, созданные в неделю, не попадают в переходящие
   - Убедиться, что закрытые тикеты не попадают в переходящие
   - Проверить фильтр по продукту

## Пример реализации

**Файл:** `api/graph-1c-admission-closure.php`

```php
/**
 * Проверка, является ли тикет переходящим
 * 
 * @param array $ticket Данные тикета
 * @param DateTimeImmutable $weekStart Начало недели (UTC)
 * @param array $targetStages Рабочие стадии
 * @param array $closingStages Закрывающие стадии
 * @return bool
 */
function isCarryoverTicket(array $ticket, DateTimeImmutable $weekStart, array $targetStages, array $closingStages): bool
{
    $createdTime = $ticket['createdTime'] ?? null;
    $stageId = $ticket['stageId'] ?? null;
    
    if (!$createdTime || !$stageId) {
        return false;
    }
    
    // Нормализация stageId
    $stageId = strtoupper($stageId);
    
    // Условие 1: Создан до начала недели
    $createdDt = new DateTimeImmutable($createdTime, new DateTimeZone('UTC'));
    if ($createdDt >= $weekStart) {
        return false; // Создан в текущую неделю, не переходящий
    }
    
    // Условие 2: Находится в рабочих стадиях
    if (!in_array($stageId, $targetStages, true)) {
        return false; // Не в рабочей стадии
    }
    
    // Условие 3: Не в закрывающих стадиях (дополнительная проверка)
    if (in_array($stageId, $closingStages, true)) {
        return false; // В закрывающей стадии
    }
    
    return true;
}

// В основном коде обработки тикетов
$carryoverCount = 0;
$carryoverTickets = []; // Для будущего использования

foreach ($tickets as $ticket) {
    // Фильтр по продукту (применяется первым)
    $product = $ticket['UF_CRM_7_TYPE_PRODUCT'] ?? $ticket['ufCrm7TypeProduct'] ?? null;
    $product = strtoupper(trim($product ?? ''));
    
    if ($product !== '1C' && $product !== '1С') {
        continue; // Пропускаем тикеты не из сектора 1С
    }
    
    $createdTime = $ticket['createdTime'] ?? null;
    $movedTime = $ticket['movedTime'] ?? $ticket['updatedTime'] ?? null;
    $stageId = $ticket['stageId'] ?? null;
    
    // Новые тикеты (созданные в неделю)
    if (isInRange($createdTime, $weekStart, $weekEnd)) {
        $newCount++;
    }
    
    // Закрытые тикеты (закрытые в неделю)
    $stageIdUpper = $stageId ? strtoupper($stageId) : null;
    if (isInRange($movedTime, $weekStart, $weekEnd) && 
        in_array($stageIdUpper, $closingStages, true)) {
        $closedCount++;
    }
    
    // Переходящие тикеты (новые в прошлом периоде, но ещё не закрыты)
    if (isCarryoverTicket($ticket, $weekStart, $targetStages, $closingStages)) {
        $carryoverCount++;
        
        // Сохранить данные тикета для будущего использования
        if ($includeCarryoverTickets) {
            $carryoverTickets[] = [
                'id' => (int)$ticket['id'],
                'title' => $ticket['title'] ?? 'Без названия',
                'createdTime' => $createdTime,
                'stageId' => $stageIdUpper,
                'assignedById' => $ticket['assignedById'] ?? null
            ];
        }
    }
}
```

## Критерии приёмки этапа

- [x] Реализована функция `isCarryoverTicket()` с проверкой всех условий
- [x] Переходящие тикеты фильтруются корректно:
  - [x] `createdTime < weekStartUtc` (создан до начала недели)
  - [x] `stageId` ∈ рабочих стадий (DT140_12:UC_0VHWE2, DT140_12:PREPARATION, DT140_12:CLIENT)
  - [x] `stageId` ∉ закрывающих стадий
- [x] Фильтр по продукту `product=1C` применяется первым шагом
- [x] Подсчитывается количество переходящих тикетов (`$carryoverCount`)
- [x] Тикеты, созданные в текущую неделю, не попадают в переходящие
- [x] Закрытые тикеты не попадают в переходящие
- [x] Логика работает корректно с существующим кодом (не ломает `newCount` и `closedCount`)

## Дополнительные уточнения

### Оптимизация запросов

**Вариант 1: Использовать существующие запросы**
- Использовать тикеты из запроса "созданные в неделю" и "закрытые в неделю"
- Но это не подходит, так как переходящие тикеты созданы ДО недели

**Вариант 2: Отдельный запрос для переходящих тикетов**
- Запрос тикетов с `createdTime < weekStartUtc`
- Фильтр по `stageId` ∈ рабочих стадий
- Фильтр по `UF_CRM_7_TYPE_PRODUCT = '1C'`
- Фильтровать на PHP, исключая закрывающие стадии

**Рекомендация:** Вариант 2, но можно оптимизировать, используя один запрос для всех тикетов с широким фильтром по дате.

### Обработка edge cases

- Если `createdTime` отсутствует — не считать переходящим
- Если `stageId` отсутствует — не считать переходящим
- Если `stageId` в неожиданном формате — нормализовать через `strtoupper()`
- Если тикет в закрывающей стадии — не считать переходящим (даже если создан до недели)

### Производительность

- Минимизировать количество запросов к Bitrix24
- Использовать эффективные фильтры в запросах
- Кэшировать результаты, если возможно

## История правок

- 2025-12-16 11:01 (UTC+3, Брест): Создан этап 1 задачи TASK-044
- 2025-12-16 17:30 (UTC+3, Брест): Реализована логика переходящих тикетов на бэкенде
  - Добавлена функция `isCarryoverTicket()` для проверки переходящих тикетов
  - Добавлен третий запрос к Bitrix24 для получения переходящих тикетов
  - Добавлен подсчёт переходящих тикетов в цикле обработки
  - Добавлено сохранение данных переходящих тикетов для будущего использования
  - Добавлен параметр `includeCarryoverTickets` в API
  - Добавлен `carryoverCount` в debug-ответ для тестирования

