# TASK-030-06: Исправление определения категории давности даты создания тикета

**Дата создания:** 2025-12-12 08:26 (UTC+3, Брест)  
**Статус:** Завершена  
**Приоритет:** Высокий  
**Исполнитель:** Bitrix24 Программист (Vue.js)  
**Родительская задача:** TASK-030

---

## Описание

Исправить ошибку в функции `getDateAccentCategory()` в файле `date-utils.js`, из-за которой тикеты, созданные вчера, могут неправильно определяться как "СЕГОДНЯ" вместо "НА ЭТОЙ НЕДЕЛЕ".

**Проблема:** При вычислении разницы в днях между датой создания тикета и текущей датой не происходит нормализация дат (сброс времени до 00:00:00), что приводит к неправильному определению категории давности.

---

## Контекст

В рамках задачи TASK-030-04 была реализована функция отображения даты создания тикета с визуальными акцентами в зависимости от категории давности. Функция `getDateAccentCategory()` определяет категорию на основе разницы между текущей датой и датой создания тикета.

**Обнаруженная проблема:**
- Тикет, созданный вчера (например, `2024-12-11 23:59:00`), может определяться как "СЕГОДНЯ", если текущая дата — сегодня ранним утром (например, `2024-12-12 00:01:00`)
- Причина: разница в миллисекундах составляет ~2 минуты, что при делении на миллисекунды в дне даёт `diffDays = 0`

**Пример проблемы:**
```javascript
// Тикет создан: 2024-12-11 23:59:00 (вчера)
// Текущая дата: 2024-12-12 00:01:00 (сегодня)
// Разница: ~2 минуты = ~0.001 дня
// diffDays = Math.floor(0.001) = 0
// Результат: "СЕГОДНЯ" (неправильно!)
```

---

## Модули и компоненты

- `vue-app/src/services/dashboard-sector-1c/utils/date-utils.js` — файл с функцией `getDateAccentCategory()` (основной файл для изменений)

---

## Зависимости

- Зависит от TASK-030-02: утилиты `date-utils.js` должны быть созданы
- Зависит от TASK-030-04: функция `getDateAccentCategory()` должна быть реализована
- Исправление не влияет на другие части системы (обратная совместимость)

---

## Детальный анализ проблемы

### 1. Текущая реализация функции `getDateAccentCategory()`

**Файл:** `vue-app/src/services/dashboard-sector-1c/utils/date-utils.js`  
**Строки:** 165-246

**Текущий код (строки 184-194):**
```javascript
// Вычисление разницы в миллисекундах
const diffMs = current - created;

// Проверка на отрицательную разницу (дата создания в будущем)
if (diffMs < 0) {
  // Если дата создания в будущем, считаем как "сегодня"
  return DATE_ACCENT_CATEGORIES.TODAY;
}

// Вычисление разницы в днях, неделях, месяцах, годах
const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
```

**Проблема:**
- При вычислении `diffMs = current - created` учитывается время (часы, минуты, секунды)
- Если тикет создан вчера в 23:59, а текущая дата — сегодня в 00:01, разница составляет ~2 минуты
- `diffDays = Math.floor(2 минуты / 24 часа) = 0` → неправильно определяется как "СЕГОДНЯ"

### 2. Примеры неправильного поведения

**Пример 1: Тикет создан вчера вечером**
```javascript
// Входные данные:
created = new Date('2024-12-11T23:59:00+02:00');  // Вчера, 23:59
current = new Date('2024-12-12T00:01:00+02:00');  // Сегодня, 00:01

// Текущий код:
diffMs = current - created = 120000 (2 минуты)
diffDays = Math.floor(120000 / 86400000) = 0

// Результат: "СЕГОДНЯ" (неправильно!)
// Ожидаемый результат: "НА ЭТОЙ НЕДЕЛЕ"
```

**Пример 2: Тикет создан сегодня утром**
```javascript
// Входные данные:
created = new Date('2024-12-12T08:00:00+02:00');  // Сегодня, 08:00
current = new Date('2024-12-12T23:59:00+02:00');  // Сегодня, 23:59

// Текущий код:
diffMs = current - created = 57540000 (~16 часов)
diffDays = Math.floor(57540000 / 86400000) = 0

// Результат: "СЕГОДНЯ" (правильно!)
```

**Пример 3: Тикет создан позавчера**
```javascript
// Входные данные:
created = new Date('2024-12-10T23:59:00+02:00');  // Позавчера, 23:59
current = new Date('2024-12-12T00:01:00+02:00');  // Сегодня, 00:01

// Текущий код:
diffMs = current - created = 864120000 (~1 день 2 минуты)
diffDays = Math.floor(864120000 / 86400000) = 1

// Результат: "НА ЭТОЙ НЕДЕЛЕ" (правильно, но может быть неправильно в других случаях)
```

### 3. Решение проблемы

**Необходимо нормализовать даты перед вычислением разницы:**
- Сбросить время до 00:00:00 для обеих дат
- Вычислить разницу между нормализованными датами
- Это обеспечит корректное определение категории на основе календарных дней, а не времени

**Алгоритм нормализации:**
```javascript
// Создать новые объекты Date с тем же годом, месяцем и днём, но временем 00:00:00
const createdNormalized = new Date(
  created.getFullYear(),
  created.getMonth(),
  created.getDate()
);
const currentNormalized = new Date(
  current.getFullYear(),
  current.getMonth(),
  current.getDate()
);
```

---

## Пошаговая реализация

### Шаг 1: Анализ текущего кода

**Действие:**
1. Открыть файл `vue-app/src/services/dashboard-sector-1c/utils/date-utils.js`
2. Найти функцию `getDateAccentCategory()` (строки 165-246)
3. Изучить текущую логику вычисления разницы в днях (строки 184-194)

**Проверка:**
- [ ] Файл найден и открыт
- [ ] Функция `getDateAccentCategory()` найдена
- [ ] Понятна текущая логика вычисления разницы

---

### Шаг 2: Добавление нормализации дат

**Действие:**
1. Найти строку 183 (после проверки валидности дат, перед вычислением разницы)
2. Добавить нормализацию дат перед вычислением разницы:

```javascript
  // Проверка на валидность дат
  if (isNaN(created.getTime()) || isNaN(current.getTime())) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_YEAR;
  }
  
  // Нормализация дат: сброс времени до 00:00:00 для корректного сравнения календарных дней
  const createdNormalized = new Date(
    created.getFullYear(),
    created.getMonth(),
    created.getDate()
  );
  const currentNormalized = new Date(
    current.getFullYear(),
    current.getMonth(),
    current.getDate()
  );
  
  // Вычисление разницы в миллисекундах между нормализованными датами
  const diffMs = currentNormalized - createdNormalized;
```

**Детальное объяснение:**
- `created.getFullYear()` — год даты создания
- `created.getMonth()` — месяц даты создания (0-11)
- `created.getDate()` — день месяца даты создания (1-31)
- `new Date(year, month, date)` — создаёт новый объект Date с временем 00:00:00
- Нормализация обеих дат гарантирует, что сравнение происходит по календарным дням, а не по времени

**Проверка:**
- [ ] Нормализация дат добавлена перед вычислением разницы
- [ ] Используются нормализованные даты для вычисления `diffMs`
- [ ] Синтаксис корректен

---

### Шаг 3: Обновление вычисления начала недели

**Действие:**
1. Найти строку 206 (определение начала текущей недели)
2. Обновить код, чтобы использовать нормализованную текущую дату:

```javascript
  // 2. НА ЭТОЙ НЕДЕЛЕ (не сегодня, но в текущей неделе)
  // Определяем начало текущей недели (понедельник)
  const startOfWeek = new Date(currentNormalized);
  const dayOfWeek = currentNormalized.getDay(); // 0 = воскресенье, 1 = понедельник, ..., 6 = суббота
  const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Дней до понедельника
  startOfWeek.setDate(currentNormalized.getDate() - daysToMonday);
  startOfWeek.setHours(0, 0, 0, 0);
  
  if (createdNormalized >= startOfWeek && diffDays < 7) {
    return DATE_ACCENT_CATEGORIES.THIS_WEEK;
  }
  
  // 3. НА ПРОШЛОЙ НЕДЕЛЕ
  const startOfLastWeek = new Date(startOfWeek);
  startOfLastWeek.setDate(startOfWeek.getDate() - 7);
  
  if (createdNormalized >= startOfLastWeek && createdNormalized < startOfWeek) {
    return DATE_ACCENT_CATEGORIES.LAST_WEEK;
  }
```

**Детальное объяснение:**
- Использование `currentNormalized` вместо `current` для определения начала недели
- Использование `createdNormalized` вместо `created` для сравнения с началом недели
- Это обеспечивает корректное сравнение календарных дней

**Проверка:**
- [ ] Все использования `current` заменены на `currentNormalized` в логике недель
- [ ] Все использования `created` заменены на `createdNormalized` в логике недель
- [ ] Синтаксис корректен

---

### Шаг 4: Обновление JSDoc комментариев

**Действие:**
1. Найти JSDoc комментарий функции `getDateAccentCategory()` (строки 130-164)
2. Обновить описание, добавив информацию о нормализации дат:

```javascript
/**
 * Определение категории давности даты
 * 
 * Определяет, к какой категории давности относится дата создания тикета,
 * на основе разницы между текущей датой и датой создания.
 * 
 * **Важно:** Даты нормализуются (время сбрасывается до 00:00:00) перед вычислением
 * разницы, чтобы обеспечить корректное сравнение календарных дней, а не времени.
 * 
 * Категории:
 * - СЕГОДНЯ — дата создания = текущая дата (календарный день)
 * - НА ЭТОЙ НЕДЕЛЕ — в течение текущей недели (не сегодня)
 * - НА ПРОШЛОЙ НЕДЕЛЕ — в течение прошлой недели
 * - БОЛЕЕ ДВУХ НЕДЕЛЬ — от 2 недель до 1 месяца
 * - ДО 1 МЕСЯЦА — от 1 месяца до 2 месяцев
 * - БОЛЕЕ 2 МЕСЯЦЕВ — от 2 месяцев до полугода
 * - БОЛЕЕ ПОЛУГОДА — от полугода до года
 * - БОЛЕЕ ГОДА — более года
 * 
 * @param {Date|string} createdDate - Дата создания тикета
 * @param {Date} currentDate - Текущая дата (по умолчанию new Date())
 * @returns {string} Категория давности (из DATE_ACCENT_CATEGORIES)
 * 
 * @example
 * // Сегодня (независимо от времени)
 * getDateAccentCategory(new Date('2024-12-11T23:59:00'), new Date('2024-12-12T00:01:00'))
 * // 'this_week' (правильно, т.к. это разные календарные дни)
 * 
 * @example
 * // Сегодня (тот же календарный день)
 * getDateAccentCategory(new Date('2024-12-11T08:00:00'), new Date('2024-12-11T23:59:00'))
 * // 'today' (правильно, т.к. это один календарный день)
 * 
 * @example
 * // Более года
 * getDateAccentCategory('2023-01-01', new Date('2024-12-11'))
 * // 'more_than_year'
 */
```

**Проверка:**
- [ ] JSDoc комментарий обновлён
- [ ] Добавлено описание нормализации дат
- [ ] Примеры обновлены с учётом нормализации
- [ ] Форматирование соответствует остальным комментариям

---

### Шаг 5: Тестирование исправления

**Действие:**
1. Создать тестовые сценарии для проверки исправления
2. Проверить все граничные случаи

**Тестовые сценарии:**

**Сценарий 1: Тикет создан вчера вечером, текущая дата — сегодня утром**
```javascript
const created = new Date('2024-12-11T23:59:00+02:00');
const current = new Date('2024-12-12T00:01:00+02:00');
const category = getDateAccentCategory(created, current);
// Ожидаемый результат: 'this_week' (не 'today')
```

**Сценарий 2: Тикет создан сегодня утром, текущая дата — сегодня вечером**
```javascript
const created = new Date('2024-12-12T08:00:00+02:00');
const current = new Date('2024-12-12T23:59:00+02:00');
const category = getDateAccentCategory(created, current);
// Ожидаемый результат: 'today'
```

**Сценарий 3: Тикет создан позавчера вечером, текущая дата — сегодня утром**
```javascript
const created = new Date('2024-12-10T23:59:00+02:00');
const current = new Date('2024-12-12T00:01:00+02:00');
const category = getDateAccentCategory(created, current);
// Ожидаемый результат: 'this_week' (2 дня назад)
```

**Сценарий 4: Тикет создан в понедельник, текущая дата — воскресенье той же недели**
```javascript
const created = new Date('2024-12-09T10:00:00+02:00'); // Понедельник
const current = new Date('2024-12-15T23:59:00+02:00'); // Воскресенье
const category = getDateAccentCategory(created, current);
// Ожидаемый результат: 'this_week'
```

**Сценарий 5: Тикет создан в воскресенье прошлой недели, текущая дата — понедельник**
```javascript
const created = new Date('2024-12-08T23:59:00+02:00'); // Воскресенье прошлой недели
const current = new Date('2024-12-09T00:01:00+02:00'); // Понедельник текущей недели
const category = getDateAccentCategory(created, current);
// Ожидаемый результат: 'last_week'
```

**Проверка:**
- [ ] Все тестовые сценарии проверены
- [ ] Результаты соответствуют ожидаемым
- [ ] Граничные случаи обработаны корректно

---

### Шаг 6: Проверка обратной совместимости

**Действие:**
1. Убедиться, что исправление не ломает существующую функциональность
2. Проверить, что все категории давности определяются корректно

**Проверка обратной совместимости:**
- [ ] Тикеты, созданные сегодня, определяются как "СЕГОДНЯ"
- [ ] Тикеты, созданные на этой неделе (не сегодня), определяются как "НА ЭТОЙ НЕДЕЛЕ"
- [ ] Тикеты, созданные на прошлой неделе, определяются как "НА ПРОШЛОЙ НЕДЕЛЕ"
- [ ] Все остальные категории работают корректно
- [ ] Визуальные акценты применяются правильно

**Проверка:**
- [ ] Обратная совместимость сохранена
- [ ] Все категории определяются корректно
- [ ] Нет регрессий в функциональности

---

## Итоговый код изменений

### Обновлённая функция `getDateAccentCategory()`

```javascript
export function getDateAccentCategory(createdDate, currentDate = new Date()) {
  // Обработка пустых значений
  if (!createdDate) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_YEAR;
  }
  
  // Преобразование в объекты Date
  const created = createdDate instanceof Date 
    ? createdDate 
    : new Date(createdDate);
  const current = currentDate instanceof Date 
    ? currentDate 
    : new Date(currentDate);
  
  // Проверка на валидность дат
  if (isNaN(created.getTime()) || isNaN(current.getTime())) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_YEAR;
  }
  
  // Нормализация дат: сброс времени до 00:00:00 для корректного сравнения календарных дней
  const createdNormalized = new Date(
    created.getFullYear(),
    created.getMonth(),
    created.getDate()
  );
  const currentNormalized = new Date(
    current.getFullYear(),
    current.getMonth(),
    current.getDate()
  );
  
  // Вычисление разницы в миллисекундах между нормализованными датами
  const diffMs = currentNormalized - createdNormalized;
  
  // Проверка на отрицательную разницу (дата создания в будущем)
  if (diffMs < 0) {
    // Если дата создания в будущем, считаем как "сегодня"
    return DATE_ACCENT_CATEGORIES.TODAY;
  }
  
  // Вычисление разницы в днях, неделях, месяцах, годах
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  const diffWeeks = Math.floor(diffDays / 7);
  const diffMonths = Math.floor(diffDays / 30); // Приблизительно 30 дней в месяце
  const diffYears = Math.floor(diffDays / 365);  // Приблизительно 365 дней в году
  
  // 1. СЕГОДНЯ
  if (diffDays === 0) {
    return DATE_ACCENT_CATEGORIES.TODAY;
  }
  
  // 2. НА ЭТОЙ НЕДЕЛЕ (не сегодня, но в текущей неделе)
  // Определяем начало текущей недели (понедельник)
  const startOfWeek = new Date(currentNormalized);
  const dayOfWeek = currentNormalized.getDay(); // 0 = воскресенье, 1 = понедельник, ..., 6 = суббота
  const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Дней до понедельника
  startOfWeek.setDate(currentNormalized.getDate() - daysToMonday);
  startOfWeek.setHours(0, 0, 0, 0);
  
  if (createdNormalized >= startOfWeek && diffDays < 7) {
    return DATE_ACCENT_CATEGORIES.THIS_WEEK;
  }
  
  // 3. НА ПРОШЛОЙ НЕДЕЛЕ
  const startOfLastWeek = new Date(startOfWeek);
  startOfLastWeek.setDate(startOfWeek.getDate() - 7);
  
  if (createdNormalized >= startOfLastWeek && createdNormalized < startOfWeek) {
    return DATE_ACCENT_CATEGORIES.LAST_WEEK;
  }
  
  // 4. БОЛЕЕ ДВУХ НЕДЕЛЬ (от 2 недель до 1 месяца)
  if (diffWeeks >= 2 && diffMonths < 1) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_TWO_WEEKS;
  }
  
  // 5. ДО 1 МЕСЯЦА (от 1 месяца до 2 месяцев)
  if (diffMonths >= 1 && diffMonths < 2) {
    return DATE_ACCENT_CATEGORIES.UP_TO_ONE_MONTH;
  }
  
  // 6. БОЛЕЕ 2 МЕСЯЦЕВ (от 2 месяцев до полугода)
  if (diffMonths >= 2 && diffMonths < 6) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_TWO_MONTHS;
  }
  
  // 7. БОЛЕЕ ПОЛУГОДА (от полугода до года)
  if (diffMonths >= 6 && diffYears < 1) {
    return DATE_ACCENT_CATEGORIES.MORE_THAN_HALF_YEAR;
  }
  
  // 8. БОЛЕЕ ГОДА (fallback для всех остальных случаев)
  return DATE_ACCENT_CATEGORIES.MORE_THAN_YEAR;
}
```

---

## Критерии приёмки

### Обязательные проверки

- [ ] Нормализация дат добавлена перед вычислением разницы
  - [ ] Создаются нормализованные версии обеих дат (время 00:00:00)
  - [ ] Используются нормализованные даты для вычисления `diffMs`
  - [ ] Используются нормализованные даты в логике определения недель

- [ ] Исправление решает проблему
  - [ ] Тикет, созданный вчера вечером, определяется как "НА ЭТОЙ НЕДЕЛЕ" (не "СЕГОДНЯ")
  - [ ] Тикет, созданный сегодня утром, определяется как "СЕГОДНЯ"
  - [ ] Все граничные случаи обработаны корректно

- [ ] Обратная совместимость сохранена
  - [ ] Все существующие категории давности определяются корректно
  - [ ] Нет регрессий в функциональности
  - [ ] Визуальные акценты применяются правильно

- [ ] JSDoc комментарии обновлены
  - [ ] Добавлено описание нормализации дат
  - [ ] Примеры обновлены с учётом нормализации
  - [ ] Форматирование соответствует остальным комментариям

### Дополнительные проверки

- [ ] Код соответствует стандартам проекта
  - [ ] ESLint не выдаёт ошибок
  - [ ] Форматирование соответствует остальному коду
  - [ ] Комментарии добавлены где необходимо

- [ ] Тестирование
  - [ ] Все тестовые сценарии проверены
  - [ ] Граничные случаи обработаны
  - [ ] Результаты соответствуют ожидаемым

---

## История правок

- **2025-12-12 08:26 (UTC+3, Брест):** Создана задача TASK-030-06
  - Добавлено описание проблемы с определением категории давности
  - Добавлен детальный анализ проблемы с примерами
  - Добавлен пошаговый план исправления
  - Добавлены критерии приёмки и тестовые сценарии

- **2025-12-12 08:26 (UTC+3, Брест):** Задача реализована
  - Добавлена нормализация дат в функции `getDateAccentCategory()`
  - Обновлены все использования дат для использования нормализованных версий
  - Обновлены JSDoc комментарии с описанием нормализации
  - Исправление протестировано, линтер не выдаёт ошибок
  - Тикеты, созданные вчера, теперь корректно определяются как "НА ЭТОЙ НЕДЕЛЕ"

---

## Связанные документы

- `DOCS/TASKS/TASK-030-ticket-card-department-and-date.md` — родительская задача
- `DOCS/TASKS/TASK-030-02-create-date-utils-and-accent-config.md` — создание утилит для работы с датами
- `DOCS/TASKS/TASK-030-04-add-created-date-with-accents-to-ticket-card.md` — добавление отображения даты создания
- `vue-app/src/services/dashboard-sector-1c/utils/date-utils.js` — файл для изменений
